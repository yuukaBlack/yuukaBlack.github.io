export const allBlogs = [{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""},{"content":"**仅包含 组合式 写法的学习，相较于 Vue2 不同之处**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\n// props声明可以使用如下方式，定义类型\nconst props = defineProps({\n\told: Number,\n\tmsg: [String, Number] // 多种类型,\n\tnum: {\n\t\ttype: Number,\n\t\trequired: true, // 必填\n\t\tdefault: 0 // 默认值\n\t},\n\tchild: {\n\t\ttype: Object,\n\t\tdefault(rawProps) {\n\t\t\treturn { msg: 'hello'}\n\t\t} // 对象和数组的默认值，要从函数返回，传参为组件接受到的原始prop\n\t},\n\t// 自定义类型校验\n\ttitle: {\n\t\tvalidator(value, props) {\n\t\t\treturn ['success', 'error'].includes(value)\n\t\t}\n\t}\n})\nconst emit = defineEmits(['enlarge-text'])\n// 可以使用如下方式进行参数验证\nconst emit = defineEmits({\n\tclick: null, // 没有校验\n\tsubmit(payload: { email: string, password: string }) {\n\t\t// 通过返回值为 true 还是 false 来判断，表明时间是否合法\n\t\t// 验证是否通过\n\t}\n})\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  props: {\n  \ttitle: String,\n\told: Number\n  }\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n#### Props\n\n1. prop命名使用小驼峰，向子组件传递时使用短横线\n2. 传递时，仅写上但不传值，会认为是true\n3. 将对象的所有属性当做props传入，使用v-bind\n4. 数据单向流动\n5. 默认都是可选的，未传递的：\n   1. 布尔类型：默认值为false\n   2. 其他类型：默认值为undefined\n6. prop的类型type是 该prop预期类型的构造函数，所以也可以是自定义的类或构造函数，vue会通过instanceof来检查类型\n7. 多种类型时，有boolean的都会进行类型转换，和string在一起 string在前面时除外\n\n#### Emit\n\n1. 和props一样，emit是使用小驼峰，父组件监听时使用短横线\n2. 组件触发的事件没有冒泡机制\n\n#### 透传\n\n1. 当组件以单个元素为根元素时，父组件透传的attribute v-on会自动添加到根元素上。class style会合并\n2. 使用inheritAttrs 可以禁用透传应用到根节点上\n3. 使用$attrs可以访问透传的所有内容（不包含声明的props和emit）\n4. 和props不同的是：不会自动转化短横线，会保留原始格式。@click会转化为 $attrs.onClick\n5. 多个根节点的组件没有自动透传行为，如果透传了参数，且没有显示绑定，则会报错\n6. 在js中使用 useAttrs() 来访问所有透传的内容。注意：这里返回的attribute不是响应式的，不能通过侦听器监听他的变化\n\n## 二、指令\n\n### 2.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 2.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 2.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 2.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 2.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n## 三、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n## 四、组件\n\n### 4.1 动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n\n### 4.2 组件命名\n\n子组件命名和使用，使用大驼峰\n\n### 4.3 Slot\n\n1. 作用域，\n   1. 渲染作用域：默认情况下，模版中的表达式只能访问其定义时所处的作用域。即插槽内容无法访问子组件的数据\n   2. 作用域插槽：插槽内容想访问子组件的数据，可以在slot时向出口传递参数\n\n      ```javascript\n      // 子组件 Head\n      <div>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head v-slot=\"slotProps\">\n      \t{{ slotProps.text}}: {{ slotProps.count }}\n      </Head>\n\n      // 具名插槽传参，name是特殊参数，不会作为props传递\n      // 子组件 Head\n      <div>\n      \t<slot name=\"head\" :text=\"msg\" :count=\"1\"></slot>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      \t<slot name=\"footer\" :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head>\n      \t<template #head=\"headerProps\">\n      \t// 使用参数，有具名slot时，默认插槽需要使用显式标签，不能使用v-slot来获取参数\n      \t<template #default=\"defaultProps\">\n      \t<template #footer=\"footerProps\">\n      </Head>\n      ```\n2. 默认内容 `<slot> submit </slot>`\n3. 具名插槽\n   1. ``<template v-slot:head>`  或者 <template #head> ``名称可以是变量\n   2. 使用name来定义slot名称 ``<slot name=\"head\"> ``没有定义的默认是default\n   3. 所有位于顶级的非template节点都被隐式的视为默认插槽的内容\n4. 无渲染组件：只包含逻辑而不需要自己渲染内容的组件\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""}]

export const tagBlogs = {"life":[{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""}],"skill":[{"content":"**仅包含 组合式 写法的学习，相较于 Vue2 不同之处**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\n// props声明可以使用如下方式，定义类型\nconst props = defineProps({\n\told: Number,\n\tmsg: [String, Number] // 多种类型,\n\tnum: {\n\t\ttype: Number,\n\t\trequired: true, // 必填\n\t\tdefault: 0 // 默认值\n\t},\n\tchild: {\n\t\ttype: Object,\n\t\tdefault(rawProps) {\n\t\t\treturn { msg: 'hello'}\n\t\t} // 对象和数组的默认值，要从函数返回，传参为组件接受到的原始prop\n\t},\n\t// 自定义类型校验\n\ttitle: {\n\t\tvalidator(value, props) {\n\t\t\treturn ['success', 'error'].includes(value)\n\t\t}\n\t}\n})\nconst emit = defineEmits(['enlarge-text'])\n// 可以使用如下方式进行参数验证\nconst emit = defineEmits({\n\tclick: null, // 没有校验\n\tsubmit(payload: { email: string, password: string }) {\n\t\t// 通过返回值为 true 还是 false 来判断，表明时间是否合法\n\t\t// 验证是否通过\n\t}\n})\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  props: {\n  \ttitle: String,\n\told: Number\n  }\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n#### Props\n\n1. prop命名使用小驼峰，向子组件传递时使用短横线\n2. 传递时，仅写上但不传值，会认为是true\n3. 将对象的所有属性当做props传入，使用v-bind\n4. 数据单向流动\n5. 默认都是可选的，未传递的：\n   1. 布尔类型：默认值为false\n   2. 其他类型：默认值为undefined\n6. prop的类型type是 该prop预期类型的构造函数，所以也可以是自定义的类或构造函数，vue会通过instanceof来检查类型\n7. 多种类型时，有boolean的都会进行类型转换，和string在一起 string在前面时除外\n\n#### Emit\n\n1. 和props一样，emit是使用小驼峰，父组件监听时使用短横线\n2. 组件触发的事件没有冒泡机制\n\n#### 透传\n\n1. 当组件以单个元素为根元素时，父组件透传的attribute v-on会自动添加到根元素上。class style会合并\n2. 使用inheritAttrs 可以禁用透传应用到根节点上\n3. 使用$attrs可以访问透传的所有内容（不包含声明的props和emit）\n4. 和props不同的是：不会自动转化短横线，会保留原始格式。@click会转化为 $attrs.onClick\n5. 多个根节点的组件没有自动透传行为，如果透传了参数，且没有显示绑定，则会报错\n6. 在js中使用 useAttrs() 来访问所有透传的内容。注意：这里返回的attribute不是响应式的，不能通过侦听器监听他的变化\n\n## 二、指令\n\n### 2.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 2.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 2.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 2.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 2.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n## 三、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n## 四、组件\n\n### 4.1 动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n\n### 4.2 组件命名\n\n子组件命名和使用，使用大驼峰\n\n### 4.3 Slot\n\n1. 作用域，\n   1. 渲染作用域：默认情况下，模版中的表达式只能访问其定义时所处的作用域。即插槽内容无法访问子组件的数据\n   2. 作用域插槽：插槽内容想访问子组件的数据，可以在slot时向出口传递参数\n\n      ```javascript\n      // 子组件 Head\n      <div>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head v-slot=\"slotProps\">\n      \t{{ slotProps.text}}: {{ slotProps.count }}\n      </Head>\n\n      // 具名插槽传参，name是特殊参数，不会作为props传递\n      // 子组件 Head\n      <div>\n      \t<slot name=\"head\" :text=\"msg\" :count=\"1\"></slot>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      \t<slot name=\"footer\" :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head>\n      \t<template #head=\"headerProps\">\n      \t// 使用参数，有具名slot时，默认插槽需要使用显式标签，不能使用v-slot来获取参数\n      \t<template #default=\"defaultProps\">\n      \t<template #footer=\"footerProps\">\n      </Head>\n      ```\n2. 默认内容 `<slot> submit </slot>`\n3. 具名插槽\n   1. ``<template v-slot:head>`  或者 <template #head> ``名称可以是变量\n   2. 使用name来定义slot名称 ``<slot name=\"head\"> ``没有定义的默认是default\n   3. 所有位于顶级的非template节点都被隐式的视为默认插槽的内容\n4. 无渲染组件：只包含逻辑而不需要自己渲染内容的组件\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""}]}
