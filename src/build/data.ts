export const allBlogs = [{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""},{"content":"## 工厂函数\n\n**用于创建新的实例对象**\n\n和构造函数的区别：\n\n1. 创建新实例的方式不同。构造函数 使用new 或者 Object.create\n2. 传参数量不同\n3. 定义位置不同，构造函数在类定义中定义\n4. 工厂函数可以创建任何类型的实例，而构造函数通常用于特定类\n\n```javascript\n// 工厂函数\nfunction createPerson(name, age) {\n\tconst person = Object.create(Person.prototype)\n\tperson.name = name\n\tperson.age = age\n\treturn person\n}\n\n// 构造函数\nclass Person {\n\tconstructor(name, age) {\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n}\n\n// 工厂函数创建实例\nconst p1 = createPerson('alice', 8)\n\n// 构造函数创建实例\nconst p2 = new Person('bob', 20)\n```\n","data":{"title":"JavaScript-函数","tag":"skill","date":"2024-04-02 10:18"},"isEmpty":false,"excerpt":""},{"content":"**装饰器是一种特殊类型的声明，能够被加到类声明、方法、访问符、属性、参数上**\n\n## 一、开启装饰器\n\n```\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n## 二、定义与使用\n\n1. 使用：@expression，expression求值后为一个表达式，装饰器在运行时被执行，被装饰的信息会作为参数传入\n\n```\n// 定义\nfunction color(value: string) { // 装饰器工厂\n\treturn function(target) { // 返回一个装饰器，会应用到目标对象上\n\t\t// 运行时执行\n\t}\n}\n\n// 使用\n@color('red')\n\n```\n\n2. 可以使用多个装饰器，同一行 多行都可。多个装饰器，会由上至下的执行装饰器工厂，然后再由下至上的执行装饰器\n3. 装饰器不能在 .d.ts 和 任何外部上下文中（例如 declare）\n\n## 三、各个装饰器\n\n*参数a：对于静态成员来说 是类的构造函数，对于实例成员是类的原型对象*\n\n| 装饰器 | 应用于               | 用于监视、修改、替换 | 参数                        | 特殊                                                                              |\n| ------ | -------------------- | -------------------- | --------------------------- | --------------------------------------------------------------------------------- |\n| 类     | 类构造函数           | 类定义               | 类的构造函数                |                                                                                   |\n| 方法   | 方法的属性描述符     | 方法定义             | a、成员名、成员的属性描述符 |                                                                                   |\n| 访问器 | 访问器的属性描述符   | 访问器的定义         | a、成员名、成员的属性描述符 | 1. 不能同时装饰一个成员的get 和set<br />2. 成员的所有装饰器应用于他的第一个访问器 |\n| 属性   | 属性                 | 属性的定义           | a、成员名                   | 无属性描述符                                                                      |\n| 参数   | 类构造函数或方法声明 | 方法的参数           | a、成员名、参数索引         |                                                                                   |\n\n## 四、元数据\n\n`reflect-metadata` 库，通过使用 Reflect API 在运行时 访问和使用ts装饰器 获取到被声明的类、方法、属性等\n\n### 4.1 开启 生成元数据\n\n为带有装饰器的声明 自动生成元数据\n\n```\n// tsconfig.json\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\n\n// index.js\nimport 'reflect-metadata'\n\n// 使用Reflect\n```\n\n### 4.2 元编程 & 元数据\n\n**什么是元编程？**\n\n通过编写代码来操作、修改代码本身。例如ts装饰器，可以在方法调用时判断参数是否合规\n\n\n**什么是元数据？**\n\n描述数据的特征、属性、配置、描述等相关信息，比如\n\n1. js中，jsdoc 来描述函数\n2. 数据库中 元数据可以描述表结构 字段等\n3. ts装饰器中，通过装饰器在运行时添加额外信息，以便在需要时使用\n","data":{"title":"TypeScript-装饰器","tag":"skill","date":"2024-04-02 09:45"},"isEmpty":false,"excerpt":""},{"content":"**仅包含 组合式 写法的学习**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\n// props声明可以使用如下方式，定义类型\nconst props = defineProps({\n\told: Number,\n\tmsg: [String, Number] // 多种类型,\n\tnum: {\n\t\ttype: Number,\n\t\trequired: true, // 必填\n\t\tdefault: 0 // 默认值\n\t},\n\tchild: {\n\t\ttype: Object,\n\t\tdefault(rawProps) {\n\t\t\treturn { msg: 'hello'}\n\t\t} // 对象和数组的默认值，要从函数返回，传参为组件接受到的原始prop\n\t},\n\t// 自定义类型校验\n\ttitle: {\n\t\tvalidator(value, props) {\n\t\t\treturn ['success', 'error'].includes(value)\n\t\t}\n\t}\n})\nconst emit = defineEmits(['enlarge-text'])\n// 可以使用如下方式进行参数验证\nconst emit = defineEmits({\n\tclick: null, // 没有校验\n\tsubmit(payload: { email: string, password: string }) {\n\t\t// 通过返回值为 true 还是 false 来判断，表明时间是否合法\n\t\t// 验证是否通过\n\t}\n})\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  props: {\n  \ttitle: String,\n\told: Number\n  }\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n#### Props\n\n1. prop命名使用小驼峰，向子组件传递时使用短横线\n2. 传递时，仅写上但不传值，会认为是true\n3. 将对象的所有属性当做props传入，使用v-bind\n4. 数据单向流动\n5. 默认都是可选的，未传递的：\n   1. 布尔类型：默认值为false\n   2. 其他类型：默认值为undefined\n6. prop的类型type是 该prop预期类型的构造函数，所以也可以是自定义的类或构造函数，vue会通过instanceof来检查类型\n7. 多种类型时，有boolean的都会进行类型转换，和string在一起 string在前面时除外\n\n#### Emit\n\n1. 和props一样，emit是使用小驼峰，父组件监听时使用短横线\n2. 组件触发的事件没有冒泡机制\n\n#### 透传\n\n1. 当组件以单个元素为根元素时，父组件透传的attribute v-on会自动添加到根元素上。class style会合并\n2. 使用inheritAttrs 可以禁用透传应用到根节点上\n3. 使用$attrs可以访问透传的所有内容（不包含声明的props和emit）\n4. 和props不同的是：不会自动转化短横线，会保留原始格式。@click会转化为 $attrs.onClick\n5. 多个根节点的组件没有自动透传行为，如果透传了参数，且没有显示绑定，则会报错\n6. 在js中使用 useAttrs() 来访问所有透传的内容。注意：这里返回的attribute不是响应式的，不能通过侦听器监听他的变化\n\n## 二、组合式函数\n\n组合式函数是一个利用 vue 的组合式 api 来封装和复用有状态逻辑的函数\n\n### 2.1 约定\n\n1. 命名：use为开头，驼峰式\n2. 输入参数，\n   1. 最好使用toValue来处理，可以规范化处理 ref getter函数 原始值\n   2. 参数如果是ref或getter，为了能够被追踪，1使用watch显式的监视，2在watchEffect中调用toValue\n3. 返回值\n   1. 返回一个包含多个ref的普通的非响应式的对象\n   2. 如果希望使用对象属性来访问，可以使用reactive来包装一下组合式函数的调用 `const mouse = reactive(useMouse())`\n4. 副作用\n   1. 服务端渲染，确保在组件挂载后再执行dom相关的副作用\n   2. 在onUnmounted中清理副作用\n5. 限制：组合式函数只能在 `<script setup> 或 setup()中调用`，只能被同步调用，也可以在生命周期中调用\n\n```javascript\n// mouse.js\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\n\tconst x = ref(0)\n\tconst y = ref(0)\n\n\tfunction update(event) {\n\t\tx.value = event.pageX\n\t\ty.value = event.pageY\n\t}\n\n\tonMounted(() => window.addEventListener('mousemove', update))\n\tonUnmounted(() => window.removeEventListener('mousemove', update))\n\n\treturn { x, y }\n}\n\n// Index.vue\n<script setup>\nimport { useMouse } from './mouse.js'\n\nconst { x, y } = useMouse()\n</script>\n\n<template>\n\t{{ x }}, {{ y }}\n</template>\n```\n\n## 三、指令\n\n### 3.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 3.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 3.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 3.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 3.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n### 3.6 自定义指令\n\n*为了重用 涉及普通元素的 底层dom访问 的逻辑*\n\n定义：\n\n1. 在 `<script setup> ` 中以v开头的驼峰式命名的变量，被用作一个自定义指令。\n2. 其他情况，需要使用 directives 选项注册\n3. app.directive 全局定义\n\n```javascript\n// 方式一\n<script setup>\nconst vFocus = {\n\tmounted: (el) => el.focus()\n}\n</script>\n\n<template>\n\t<input v-focus />\n</template>\n\n// 方式二\n<script>\nexport default {\n\tsetup() {}\n\tdirectives: {\n\t\tfocus: {\n\t\t\t//\n\t\t}\n\t}\n}\n</script>\n\n// 全局注册\nconst app = createApp({})\n\napp.directive('focus', {\n\t// \n})\n\n// 简化形式，在mounted和updated是执行此函数\napp.directive('color', (el, binding) => {\n\tel.style.color = binding.value\n})\n```\n\n指令钩子\n\n1. created 绑定元素的 attribute 前，时间监听器应用前\n2. beforeMount  元素被插入dom前调用\n3. mounted 元素的父组件、子节点都挂载完成后调用\n4. beforeUpdate 元素的父组件更新前调用\n5. updated 元素的父组件、子节点都更新后调用\n6. beforeUnmount 元素的父组件卸载前调用\n7. unmounted 元素的父组件卸载后调用\n\n钩子参数\n\n1. el 指令绑定到的元素\n2. binding 对象\n   1. value 传递给指令的值 `v-focus=\"2\"`\n   2. oldValue 之前的值\n   3. arg 传递给指令的参数 `v-focus:bar, ` 参数可以是动态的\n   4. modifiers 修饰符对象 `v-focus.foo.bar `对象是，`{ foo: true, bar: true }`\n   5. instance 使用该指令的组件实例\n   6. dir 指令的定义对象\n3. vnode 绑定元素的底层VNode\n4. preVnode 之前的渲染中指令所绑定的VNode\n\n*当在组件上使用自定义指令时，会始终应用于组件的根节点。但是不推荐在组件上使用自定义指令*\n\n## 四、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n## 五、组件\n\n### 5.1 动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n\n### 5.2 组件命名\n\n子组件命名和使用，使用大驼峰\n\n### 5.3 Slot\n\n1. 作用域，\n   1. 渲染作用域：默认情况下，模版中的表达式只能访问其定义时所处的作用域。即插槽内容无法访问子组件的数据\n   2. 作用域插槽：插槽内容想访问子组件的数据，可以在slot时向出口传递参数\n\n      ```javascript\n      // 子组件 Head\n      <div>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head v-slot=\"slotProps\">\n      \t{{ slotProps.text}}: {{ slotProps.count }}\n      </Head>\n\n      // 具名插槽传参，name是特殊参数，不会作为props传递\n      // 子组件 Head\n      <div>\n      \t<slot name=\"head\" :text=\"msg\" :count=\"1\"></slot>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      \t<slot name=\"footer\" :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head>\n      \t<template #head=\"headerProps\">\n      \t// 使用参数，有具名slot时，默认插槽需要使用显式标签，不能使用v-slot来获取参数\n      \t<template #default=\"defaultProps\">\n      \t<template #footer=\"footerProps\">\n      </Head>\n      ```\n2. 默认内容 `<slot> submit </slot>`\n3. 具名插槽\n   1. ``<template v-slot:head>`  或者 <template #head> ``名称可以是变量\n   2. 使用name来定义slot名称 ``<slot name=\"head\"> ``没有定义的默认是default\n   3. 所有位于顶级的非template节点都被隐式的视为默认插槽的内容\n4. 无渲染组件：只包含逻辑而不需要自己渲染内容的组件\n\n### 5.4 异步组件\n\n在需要时再从服务器加载相关组件\n\n使用 defineAsyncComponent 和 es模块动态导入 import，vite和webpack支持此语法，并且会将它们作为打包时的代码分割点\n\n```javascript\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n\timport('./head/Head.vue')\n})\n\n// 也可以使用全局注册\napp.component('Head', defineAsyncComponent(() => {\n\timport('./head/Head.vue')\n}))\n\n// 支持高级选项处理加载错误状态\nconst AsyncComp = defineAsyncComponent({\n\tloader: import('./head/Head.vue'),\n\tloadingComponent: Load, // 在异步组件加载时展示\n\tdelay: 200, // 加载前有200ms的延迟，为了可以完整展示加载组件\n\terrorComponent: Error, // 加载失败时展示的组件\n\ttimeout: 3000, // 超过3000ms还没加载出来，就展示失败组件\n})\n\n\n// 搭配Suspense组件使用\n```\n\n### 5.5 依赖注入\n\nprovide, inject\n\n```javascript\n// 父组件\nimport { provide, readonly } from 'vue;\n\nprovide('msg', 'hello'); // key值可以是string或symbol\n\n// value可以是任意类型，包含ref，可以和后代组件建立响应式联系\nconst num = ref(0)\nprovide('num', num);\n\n// 使用readonly来确保提供的数据不能被子组件更改\nprovide('num-only', readonly(num))\n\n\n// 在整个应用层面提供依赖\nimport { createApp } from 'vue';\n\nconst app = createApp({})\napp.provide('msg', 'hello')\n\n\n// 子组件\nimport { inject } from 'vue';\n\nconst msg = inject('msg')\nconst num = inject('num') // 不会自动解构\n\n// 如果在注入时不要求必须有提供者，那么需要提供一个默认值\nconst head = inject('head', 'haha')\n\n// 默认值需要函数调用或初始化类获取时，可以使用工厂函数来避免在用不到默认值的情况下不进行计算，\n// 需要传递第三个参数来表示默认值是工厂函数\nconst value = inject('key', () => getValue(), true)\n\n```\n\n*注意：将响应式的变更都放在提供方组件中，如果需要在子组件更改的话，应该在提供方组件中提供一个更改数据的函数*\n\n### 5.6 内置组件\n\n#### Transition\n\n*在一个元素或组件进入和离开DOM时应用动画，仅支持单个元素，或有一个根元素的组件*\n\n进入和离开时，会先检测css过渡或动画，再调用监听的 js 钩子，再执行\n\n1. 触发条件：`v-if`、`v-show`、`v-if` / `v-else` / `v-else-if`、`key`属性改变、由 `<component> `切换的动态组件。\n2. 动画各个阶段的class，可以为class写css动画:\n\n   ![1712815739846](assets/image/20240222/1712815739846.png)\n\n   * 可以使用 name 自定义前缀：`<transition name=\"yu\"> ，那么 v-enter-from -> yu-enter-from `，name支持变量\n   * 自定义class，使用第三方css动画库时会用到：`<transition enter-active-class=\"animate__active\">`\n   * 阶段开始时，class自动添加至元素上，完成后，class自动被移除。\n   * 过渡结束事件：transitionend 或 animationend，取决于使用了哪个css，如果都有使用，则需要使用type来确定事件。`<transition type=\"animation\" >`\n   * 可以使用选择器为深层次的子元素写 css 动画，可以使用 duration 属性来指定过渡的总时间\n   * 性能考虑：使用transform  opacity这种不会影响dom结构 不会进行css布局重新计算的，height margin这种需谨慎使用\n3. js 钩子\n\n   ```javascript\n   <Transition\n     :css=\"false\" \n     // 默认事件会在css动画和js执行的动画时 都触发。\n     // 如果仅是js执行动画，可以加上这个属性，表明不会自动添加和移除class，可以跳过css过渡的探测，性能好\n     // 此时 钩子回调函数的done就是必须的，在过渡效果完成后调用，否则回调函数执行完就认为过渡完成\n     @before-enter=\"onBeforeEnter\"\n     @enter=\"onEnter\" // 开始插入，开始进入动画\n     @after-enter=\"onAfterEnter\"\n     @enter-cancelled=\"onEnterCancelled\"\n     @before-leave=\"onBeforeLeave\"\n     @leave=\"onLeave\"\n     @after-leave=\"onAfterLeave\"\n     @leave-cancelled=\"onLeaveCancelled\"\n   >\n     <!-- ... -->\n   </Transition>\n\n   ```\n4. 可封装 Transition 组件，从而复用过渡效果\n5. 其他属性:\n\n   * appear 只在元素初次渲染时应用\n   * mode 过渡模式 out-in 表示 先执行离开动画再执行进入动画\n\n#### TransitionGroup\n\n*用于对v-for列表中的元素或组件的插入、移除和顺序改变添加动画效果*\n\n支持和Transition一样的class 属性 js钩子等\n\n特殊：\n\n1. 需要使用 tag 来指定容器元素\n2. mode 属性不可用\n3. 列表中的元素必须有唯一的 key\n4. class 会被添加至列表内的元素，而不是容器元素\n5. class 新增 v-move 表示对移动中的元素的过渡\n\n```javascript\n<TranstionGroup name=\"list\" tag=\"ul\">\n\t<li v-for=\"item in items\" :key=\"item.id\">\n\t\t{{ item.msg }}\n\t</li>\n</TransitionGroup>\n```\n\n#### KeepAlive\n\n*在多个组件间动态切换时 缓存被移除的组件实例*\n\n```javascript\n// 在切换组件时，会缓存组件状态，切换回来时 状态保留\n\n<KeepAlive>\n\t<component is=\"activeComp\" />\n</KeepAlive>\n\n// 默认会缓存内部所有的组件实例，但可以通过 include 和 exclude 来定制该行为\n// 值可以使逗号分隔的字符串、正则表达式、数组，会根据组件的 name 进行匹配\n\n<KeepAlive include=\"a,b\">\n\t<component is=\"activeComp\" />\n</KeepAlive>\n\n// 使用 max 来限制可被限制的最大组件实例数，超过时，最久没被访问的缓存实例被销毁\n```\n\n被切换时，从dom上移除，但是由于被缓存而作为组件树的一部分，状态变为不活跃而不是被卸载。\n\n当切换回来时，会插入到DOM中，将被激活\n\n生命周期钩子，不仅适用于KeepAlive缓存的根组件，也适用于缓存树中的后代组件：\n\n1. onActivated 首次挂载 和 从缓存中被重新插入时\n2. onDeactivated 从dom移除 进入缓存时，和 卸载时\n\n\n#### Teleport\n\n*将一个组件内部的一部分模版“传送”到该组件的 DOM 结构外层的位置去*\n\n1. to 来指定传送的目标。to 可以是 选择器字符串 或 dom元素对象\n2. disabled 禁用传送，当做行内元素\n3. 多个teleport to一个目标，按顺序依次追加\n\n```javascript\n<template>\n\t<button @click=\"open = true\"> open modal </button>\n\t<Teleport to=\"body\">\n\t\t<div v-if=\"open\" class=\"modal\">\n\t\t...\n\t\t</div>\n\t</Teleport>\n</template>\n```\n\n\n#### Suspense\n\n协调 子组件树中 所有异步资源的处理，可以等待下层的所有异步资源解析完成，可以在等待时渲染一个加载状态\n\n1. 可以协调的异步资源：\n   1. 带有异步 setup 的组件，即 setup() 中有 await\n   2. `<script setup>` 时顶层有 await\n   3. 异步组件，异步组件中自定义的加载、报错、延时等配置均被忽略。但可以指定 suspensible: false 表明不用Suspense 控制\n2. 插槽，defauult、fallback。均只允许一个直接子节点\n   1. 初始渲染时，渲染默认插槽内容，如果有任何异步依赖，则进入挂起状态，渲染fallback插槽内容。当所有异步依赖都完成后，则进入完成状态，渲染默认插槽的内容\n   2. 当默认插槽被替换时，suspense会回到挂起状态，但是不会展示fallback插槽，而是展示之前默认插槽的内容。可以使用timeout进行控制此行为，timeout表示渲染耗时多久后会展示fallback插槽\n3. 事件\n   1. pending 进入挂起状态\n   2. resolve 默认插槽完成获取新内容时\n   3. fallback fallback插槽显示时\n4. 错误处理：在使用suspense的组件中。使用errorCaptured 选项 或者 onErrorCapture钩子\n\n\n\n## 六、插件\n\n*是一种能为Vue添加全局功能的工具代码*\n\n```javascript\n// 使用\napp.use(myPlugin, {\n\t// 额外参数\n})\n\n// 定义\nconst myPlugin = {\n\tinstall(app, options) {\n\t\t// app为安装此插件的应用实例，options为额外参数\n\t\t// 插件代码\n\t\t// 可以使用app.provide提供一些内容\n\t}\n}\n```\n\n### 6.1 使用范围\n\n1. 通过 app.component 和 app.directive 注册一到多个全局组件或自定义指令\n2. 通过 app.provide 使一个资源可被注入进整个应用\n3. 向 app.config.globalProperties 中添加一些全局实例属性或方法\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""},{"content":"## 一、编译相关\n\nvue 提供了多种格式的 构建文件\n\n1. 前缀为 vue.runtime. 的文件是只包含运行时的版本，不包含编译器。当使用这个版本时，所有的模板都必须由构建步骤预先编译\n2. 名称中不含 .runtime 的文件是完全版，包含编译器。支持在浏览器中直接编译模板\n\n## 二、路由\n\n1. 服务端路由：用户发送一个http请求，服务端解析请求，返回响应结果。比如传统的服务端渲染，当用户交互更改url，会请求服务端获取新的html，浏览器加载整个页面\n2. 客户端路由：对于这种单页应用，客户端监听路由更改（即拦截跳转请求），动态获取新的数据，更新页面\n\n## 三、测试\n\n> 使用 Vitest（不基于浏览器，所以快，但是捕捉不到样式问题、原生dom问题、cookie等\n>\n> 使用 Cypress （基于浏览器的运行器，由于要执行打开浏览器，编译样式表等，所以慢\n\n### 1. 单元测试\n\n*适用于独立的JS\\TS模块：业务逻辑、组件、类、模块或函数。不涉及UI、网络请求或环境问题*\n\n针对于 Vue 的特殊的单元测试\n\n1. 组合式函数\n   1. 依赖于宿主组件，包含生命周期钩子、供给/注入。需要被包装在一个宿主组件中才可以测试\n\n      ```javascript\n      // 编写一个帮手函数，创建一个组件，并且在组件中执行组合式函数\n      // test-utils.js\n      import { createApp } from 'vue'\n\n      export function withSetup(composable) {\n        let result\n        const app = createApp({\n          setup() {\n            result = composable()\n            // 忽略模板警告\n            return () => {}\n          }\n        })\n        app.mount(document.createElement('div'))\n        // 返回结果与应用实例\n        // 用来测试供给和组件卸载\n        return [result, app]\n      }\n\n      import { withSetup } from './test-utils'\n      import { useFoo } from './foo'\n\n      test('useFoo', () => {\n        const [result, app] = withSetup(() => useFoo(123))\n        // 为注入的测试模拟一方供给\n        app.provide(...)\n        // 执行断言\n        expect(result.foo.value).toBe(1)\n        // 如果需要的话可以这样触发\n        app.unmount()\n      })\n      ```\n   2. 不依赖于宿主组件。直接调用并断言其返回的状态或方法\n\n      ```javascript\n      // counter.js\n      import { ref } from 'vue'\n\n      export function useCounter() {\n        const count = ref(0)\n        const increment = () => count.value++\n\n        return {\n          count,\n          increment\n        }\n      }\n\n      // counter.test.js\n      import { useCounter } from './counter.js'\n\n      test('useCounter', () => {\n        const { count, increment } = useCounter()\n        expect(count.value).toBe(0)\n\n        increment()\n        expect(count.value).toBe(1)\n      })\n      ```\n2. 组件\n   1. 白盒：单元测试，对组件进行更独立的测试\n   2. 黑盒：组件测试，测试组件在整个系统中的集成情况\n\n### 2. 组件测试\n\n*组件测试关注 prop 事件 slot 样式 生命周期钩子 用户交互 等，只关注组件做了什么，而不是如何实现的。*\n\n*所以不要测试组件的私有状态或私有方法。如果想测试一个私有方法，应该把他提到独立的实用函数中，然后写他的单元测试*\n\n```javascript\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\n\nconst wrapper = mount(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\nexpect(wrapper.find(valueSelector).text()).toContain('0')\n\nawait wrapper.find(buttonSelector).trigger('click')\n\nexpect(wrapper.find(valueSelector).text()).toContain('1')\n```\n\n### 3. 端到端测试\n\n*完全依靠在真实浏览器中浏览整个页面来测试你的应用， 测试 当用户实际使用你的应用时发生了什么*\n\n**推荐方案：Cypress**\n\n选择端到端测试方案 需要考虑的因素：\n\n1. 跨浏览器测试：了解应用在多个不同浏览器上运行的情况\n2. 更快的反馈：集成和部署（CI/CD） 快，支持本地开发时单独测试某个页面，支持热重载\n3. 调试体验\n4. 无头模式下的可见性：在CI/CD运行时，即在无界面的浏览器中运行。需要能查看应用的快照、视频，从而了解错误的原因\n\n\n## 四、服务端渲染（SSR)\n\n> 默认情况下，vue是在浏览器生成和操作dom。服务端渲染指的是，vue支持将组件在服务器生成html字符串，然后通过响应返回给浏览器，然后浏览器再将html字符串生成可交互的应用\n\n### 4.1 SSR的优势\n\n1. **更快的首屏加载**。无需等待浏览器将资源下载、执行后才展示；对于需要有数据请求的应用，有更快的数据库连接。\n2. 前后端统一语言\n3. 更好的seo，html中是完整的内容\n\n### 4.2 SSR的劣势\n\n1. 开发限制。第三方库在服务端渲染的应用中使用、一些浏览器端特定的代码执行\n2. 构建、部署限制。客户端渲染的应用是build后的文件夹部署在服务器上。SSR 由于用户交互时，会请求服务端拿到html进行渲染，所以还需要有node环境来运行服务端代码，以及可能的数据库连接等\n3. 更高的服务端负载\n\n是否使用SSR  取决于是否有很强烈的 **首屏加载速度** 要求\n\n### 4.3 SSG静态站点（预渲染）\n\n在构建过程，完成渲染，生成的html作为静态文件被服务器托管，每次请求时直接返回，不需要重新生成\n\n如果SSR渲染的页面对于所有人都是一样的，数据也都一样，比如/about  /contact 、博客网站等，那么可以使用SSG\n\n和SSR一样 有很好的首屏加载速度。但是比SSR花销更小，更容易部署\n\n### 4.4 实现服务端渲染\n\n1. 写通用内容：构建应用\n2. 写service：\n   1. 接口请求，构建应用，构建后的转成html string，拼完整的html，返回\n   2. 端口监听\n   3. 支持浏览器加载客户端文件\n3. 写client：构建和service一样的应用，挂载到dom上，用于用户交互时有反应\n\n更通用的方案：Nuxt 、Quasar\n\n### 4.4 书写SSR规范\n\n1. SSR期间避免响应性，都使用请求+service返回新的html\n2. 生命周期函数不会在SSR期间调用，只会在客户端运行\n3. 不要在SSR期间使用客户端特有api，比如window  document\n4. 状态污染。需要在每个请求中创建一个全新的实例，包括router和store，然后使用provide将store注入\n5. 激活不匹配，需要避免以下的问题\n   1. 不符合规范的html结构\n   2. 渲染所用的数据用到了随机数\n   3. 客户端和服务端时区，会不一致\n","data":{"title":"Vue 应用规模化","tag":"skill","date":"2024-04-26 17:50"},"isEmpty":false,"excerpt":""},{"content":"## 一、数组\n\n### 1. reduce\n\n> 对数组中的每个元素按序执行一个函数，每次运行函数会将上一次运行的结果作为参数传入，返回值为最后一次的运行结果\n\n参数：\n\n1. callbackFn(accumulator, currentValue)\n2. initialValue，不传时，初始值为第一个元素，即 accumulator 为 arr[0]，currentValue 为 arr[1]\n\n返回值：计算总值\n\n*获取不到 accumulator 时，会报错。即数组为空且无 initialValue 时*\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst initialValue = 0;\nconst sum = a.reduce((accumulator, currentValue) => accumulator + currentValue, initialValue)\n\nconsole.log(sum) // 10\n```\n\n\n\n### 2. reduceRight\n\n> 和reduce 不同之处在于：数组从右往左执行函数\n\n\n### 3. slice\n\n> 对原数组的浅拷贝，返回一个新数组，原数组不会被改变\n\n参数：[start, end)\n\n1. 如果是负数，则从数组末尾开始计算，-1 表示最后一个。\n2. start 非必填，默认从0开始\n3. end 非必填，默认为arr.length\n\n返回值：浅拷贝的新数组\n\n```javascript\nconst a = [1, 2, 3, 4]\nconst b = a.slice(1, 2) // 2\n```\n\n### 4. splice\n\n> **就地**移除或替换数组元素\n\n参数\n\n1. start，必填，开始计算的索引\n2. deleteCount，删除的数量\n3. item1 ... itemN，要加入数组的元素\n\n返回值：包含删除元素的数组\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst b = a.splice(1, 2, 'c')\n\nconsole.log(a) // [1, 'c', 4 ]\nconsole.log(b) // [2, 3]\n```\n\n### 5. toSpliced\n\n> 和splice方法不同的是：\n>\n> 1. 不会更改原数组，是返回一个新数组\n> 2. 不会返回稀疏数组，空槽会被替换成undefined\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst b = a.splice(1, 2, 'c')\n\nconsole.log(a) // [1, 2, 3, 4]\nconsole.log(b) // [1, 'c', 4]\n```\n","data":{"title":"常用的 js 方法","tag":"skill","date":"2024-04-26 09:44"},"isEmpty":false,"excerpt":""},{"content":"## 一、背景\n\n业务需要在网络环境差时也可使用，所以希望实现离线存储和同步。\n\n## 二、目的\n\n无网时功能可以正常使用，有网时可以将操作的数据同步至远端。\n\n## 三、整体方案\n\n1. 搭建本地数据库，按照组织进行分库。按照业务进行表搭建\n2. 在线时，拉取数据：各个业务进行网络请求，将数据写入本地数据库\n3. 离线时，拦截请求：各个业务针对接口写拦截器，增删改查本地数据库的数据，增删改操作入log表\n4. 在线时，推送数据：遍历log表，执行对应业务的对应函数，进行网络请求，从而进行数据同步\n\n## 四、具体实现\n\n### 4.1 数据库搭建\n\n业务要求：当前业务场景，存在多个组织，且不同组织数据不同。希望在线时可以同步多个组织的数据，即切换组织时不要清库。\n\n所以决定根据组织 id 分库，当前操作的数据库，为当前组织id的库\n\n数据库搭建和数据操作使用 dexie，它是 indexDB 的包装库\n\n1. 针对表构建，写装饰器，从而方便进行表定义\n\n   1. @Entity：建表。将class放在allEntity set中，并为这个class 增加 Info: { name } 的元数据\n   2. @column 定义一个表字段 columnKey。为这个 class 增加 columnKey: { ..., 属性名 } 的元数据\n   3. @IndexColumn 定义一个可索引字段 indexKey。为这个class 增加 indexKey: { ..., 属性名 } 的元数据\n   4. @PrimaryColumn 定义一个主键 primaryKey，可用于update delete。为这个class 增加 { primaryKey: 属性名 } 的元数据\n2. 基于dexie 封装 indexDBStore，创建实例，封装 CURD 方法\n\n   1. select：\n      1. 获取到当前this，即当前表，即当前class的info元数据，获取到了表名\n      2. 获取 primaryKey 元数据，获取到了主键\n      3. 获取 indexKey 元数据，获取到了可索引属性名list\n      4. 调用dexie api 来 select 库中此表的查询数据\n   2. insert\n   3. update\n   4. delete\n   5. clear\n3. 封装表的相关方法，获取表、基于 IndexDBStore 封装从这个表中CURD的方法\n\n   1. getRespository：返回 包含下面 CURD 方法的对象\n      1. select：indexDBStore.select.bind(A)  A是定义的某个表class\n      2. insert\n      3. update\n      4. delete\n      5. clear\n4. 新增_localId字段：表中插入一个数据时，会新增_localId字段，来作为主键，唯一标识表中此条数据\n\n### 4.2 离线操作日志 搭建\n\n#### 4.2.1 Log表字段：\n\n1. id\n2. bizCode，业务标识\n3. type，操作标识\n4. bizLocalIds，执行的数据在业务表中的localId（主键），根据这个可以拿到完整的数据\n5. params，get接口 参数\n6. body，post接口 参数\n7. isSync，是否同步过\n\n#### 4.2.2 操作日志方案：\n\n1. 离线时，业务的所有增删改操作，都作为操作日志入log表\n2. 在线同步时，遍历log表，根据bizCode 执行对应的业务，根据type 执行对应的具体操作。\n\n#### 4.2.3 各个业务有如下数据，用于UI交互\n\n1. total\n2. count\n3. status\n\n#### 4.2.4 各个业务表，增加 realId 字段\n\n1. 默认值为id字段的值。\n2. 同步时，add一个数据后，接口会返回数据的真实id，然后将这个真实id存到业务表中对应数据的realId字段中。目的是后续如果有其他业务关联这条数据的话，可以关联到真实id\n\n### 4.3 拦截器\n\n1. 各个业务写各自接口的拦截器，参数1：url，参数2：拦截后的执行函数\n2. 将这些拦截器存到mapper中\n3. 使用 axios.create 创建一个 axios 实例\n4. 使用 interceptors 拦截请求，进行请求头等处理操作\n5. 使用 axios-mock-adapter 拦截到请求，进行响应处理。当在线时，返回原有的接口请求。离线时，执行mapper中url对应的执行函数\n\n### 4.4 在线同步\n\n![1714379419164](assets/image/离线存储&同步/1714379419164.png)\n\n### 4.5 业务开发\n\n在线场景，同步功能\n\n1. 各个业务 注册多个任务，各个任务包含执行函数和状态，store中存储各个任务的状态，在执行任务时先判断状态，如果被取消 或者 失败，则抛出异常，中断任务，后续任务也不进行。\n2. 开始同步\n   1. 下载基础数据 common data\n   2. 上传 业务数据\n   3. 下载 业务数据\n3. 取消同步：更改任务的状态\n\n离线场景，拦截器\n\n1. 构建表结构\n2. 使用正则表达式url拦截接口请求，进行数据的增删改查操作\n3. 应用入口使用此业务拦截器插件\n\n### 4.4 调试工具\n\n1. mock数据 写入数据库\n2. 查看数据库\n3. 清空数据库\n\n### 4.5 目录结构\n\n```javascript\n---entity // 表定义\n   ---a // 表a\n   ---b\n   ...\n---offline // 离线\n   ---helper // 调试工具\n   ---store // 装饰器、表增删改查方法\n   ...\n---sync // 同步\n   ---syncBaseData // 同步基础数据\n   ---syncAData // 同步业务A数据\n   ---useSyncBaseData // 注册任务、执行任务、取消同步。。返回状态\n   ---useSyncAData\n   ---taskManage // 任务管理封装\n   ...\n---a // 业务a\n   ---offline // 业务a 相关接口的拦截器\n   ...\n```\n","data":{"title":"离线存储 & 同步","tag":"skill","date":"2024-04-01 16:00"},"isEmpty":false,"excerpt":""}]

export const tagBlogs = {"life":[{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""}],"skill":[{"content":"## 工厂函数\n\n**用于创建新的实例对象**\n\n和构造函数的区别：\n\n1. 创建新实例的方式不同。构造函数 使用new 或者 Object.create\n2. 传参数量不同\n3. 定义位置不同，构造函数在类定义中定义\n4. 工厂函数可以创建任何类型的实例，而构造函数通常用于特定类\n\n```javascript\n// 工厂函数\nfunction createPerson(name, age) {\n\tconst person = Object.create(Person.prototype)\n\tperson.name = name\n\tperson.age = age\n\treturn person\n}\n\n// 构造函数\nclass Person {\n\tconstructor(name, age) {\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n}\n\n// 工厂函数创建实例\nconst p1 = createPerson('alice', 8)\n\n// 构造函数创建实例\nconst p2 = new Person('bob', 20)\n```\n","data":{"title":"JavaScript-函数","tag":"skill","date":"2024-04-02 10:18"},"isEmpty":false,"excerpt":""},{"content":"**装饰器是一种特殊类型的声明，能够被加到类声明、方法、访问符、属性、参数上**\n\n## 一、开启装饰器\n\n```\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n## 二、定义与使用\n\n1. 使用：@expression，expression求值后为一个表达式，装饰器在运行时被执行，被装饰的信息会作为参数传入\n\n```\n// 定义\nfunction color(value: string) { // 装饰器工厂\n\treturn function(target) { // 返回一个装饰器，会应用到目标对象上\n\t\t// 运行时执行\n\t}\n}\n\n// 使用\n@color('red')\n\n```\n\n2. 可以使用多个装饰器，同一行 多行都可。多个装饰器，会由上至下的执行装饰器工厂，然后再由下至上的执行装饰器\n3. 装饰器不能在 .d.ts 和 任何外部上下文中（例如 declare）\n\n## 三、各个装饰器\n\n*参数a：对于静态成员来说 是类的构造函数，对于实例成员是类的原型对象*\n\n| 装饰器 | 应用于               | 用于监视、修改、替换 | 参数                        | 特殊                                                                              |\n| ------ | -------------------- | -------------------- | --------------------------- | --------------------------------------------------------------------------------- |\n| 类     | 类构造函数           | 类定义               | 类的构造函数                |                                                                                   |\n| 方法   | 方法的属性描述符     | 方法定义             | a、成员名、成员的属性描述符 |                                                                                   |\n| 访问器 | 访问器的属性描述符   | 访问器的定义         | a、成员名、成员的属性描述符 | 1. 不能同时装饰一个成员的get 和set<br />2. 成员的所有装饰器应用于他的第一个访问器 |\n| 属性   | 属性                 | 属性的定义           | a、成员名                   | 无属性描述符                                                                      |\n| 参数   | 类构造函数或方法声明 | 方法的参数           | a、成员名、参数索引         |                                                                                   |\n\n## 四、元数据\n\n`reflect-metadata` 库，通过使用 Reflect API 在运行时 访问和使用ts装饰器 获取到被声明的类、方法、属性等\n\n### 4.1 开启 生成元数据\n\n为带有装饰器的声明 自动生成元数据\n\n```\n// tsconfig.json\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\n\n// index.js\nimport 'reflect-metadata'\n\n// 使用Reflect\n```\n\n### 4.2 元编程 & 元数据\n\n**什么是元编程？**\n\n通过编写代码来操作、修改代码本身。例如ts装饰器，可以在方法调用时判断参数是否合规\n\n\n**什么是元数据？**\n\n描述数据的特征、属性、配置、描述等相关信息，比如\n\n1. js中，jsdoc 来描述函数\n2. 数据库中 元数据可以描述表结构 字段等\n3. ts装饰器中，通过装饰器在运行时添加额外信息，以便在需要时使用\n","data":{"title":"TypeScript-装饰器","tag":"skill","date":"2024-04-02 09:45"},"isEmpty":false,"excerpt":""},{"content":"**仅包含 组合式 写法的学习**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\n// props声明可以使用如下方式，定义类型\nconst props = defineProps({\n\told: Number,\n\tmsg: [String, Number] // 多种类型,\n\tnum: {\n\t\ttype: Number,\n\t\trequired: true, // 必填\n\t\tdefault: 0 // 默认值\n\t},\n\tchild: {\n\t\ttype: Object,\n\t\tdefault(rawProps) {\n\t\t\treturn { msg: 'hello'}\n\t\t} // 对象和数组的默认值，要从函数返回，传参为组件接受到的原始prop\n\t},\n\t// 自定义类型校验\n\ttitle: {\n\t\tvalidator(value, props) {\n\t\t\treturn ['success', 'error'].includes(value)\n\t\t}\n\t}\n})\nconst emit = defineEmits(['enlarge-text'])\n// 可以使用如下方式进行参数验证\nconst emit = defineEmits({\n\tclick: null, // 没有校验\n\tsubmit(payload: { email: string, password: string }) {\n\t\t// 通过返回值为 true 还是 false 来判断，表明时间是否合法\n\t\t// 验证是否通过\n\t}\n})\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  props: {\n  \ttitle: String,\n\told: Number\n  }\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n#### Props\n\n1. prop命名使用小驼峰，向子组件传递时使用短横线\n2. 传递时，仅写上但不传值，会认为是true\n3. 将对象的所有属性当做props传入，使用v-bind\n4. 数据单向流动\n5. 默认都是可选的，未传递的：\n   1. 布尔类型：默认值为false\n   2. 其他类型：默认值为undefined\n6. prop的类型type是 该prop预期类型的构造函数，所以也可以是自定义的类或构造函数，vue会通过instanceof来检查类型\n7. 多种类型时，有boolean的都会进行类型转换，和string在一起 string在前面时除外\n\n#### Emit\n\n1. 和props一样，emit是使用小驼峰，父组件监听时使用短横线\n2. 组件触发的事件没有冒泡机制\n\n#### 透传\n\n1. 当组件以单个元素为根元素时，父组件透传的attribute v-on会自动添加到根元素上。class style会合并\n2. 使用inheritAttrs 可以禁用透传应用到根节点上\n3. 使用$attrs可以访问透传的所有内容（不包含声明的props和emit）\n4. 和props不同的是：不会自动转化短横线，会保留原始格式。@click会转化为 $attrs.onClick\n5. 多个根节点的组件没有自动透传行为，如果透传了参数，且没有显示绑定，则会报错\n6. 在js中使用 useAttrs() 来访问所有透传的内容。注意：这里返回的attribute不是响应式的，不能通过侦听器监听他的变化\n\n## 二、组合式函数\n\n组合式函数是一个利用 vue 的组合式 api 来封装和复用有状态逻辑的函数\n\n### 2.1 约定\n\n1. 命名：use为开头，驼峰式\n2. 输入参数，\n   1. 最好使用toValue来处理，可以规范化处理 ref getter函数 原始值\n   2. 参数如果是ref或getter，为了能够被追踪，1使用watch显式的监视，2在watchEffect中调用toValue\n3. 返回值\n   1. 返回一个包含多个ref的普通的非响应式的对象\n   2. 如果希望使用对象属性来访问，可以使用reactive来包装一下组合式函数的调用 `const mouse = reactive(useMouse())`\n4. 副作用\n   1. 服务端渲染，确保在组件挂载后再执行dom相关的副作用\n   2. 在onUnmounted中清理副作用\n5. 限制：组合式函数只能在 `<script setup> 或 setup()中调用`，只能被同步调用，也可以在生命周期中调用\n\n```javascript\n// mouse.js\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\n\tconst x = ref(0)\n\tconst y = ref(0)\n\n\tfunction update(event) {\n\t\tx.value = event.pageX\n\t\ty.value = event.pageY\n\t}\n\n\tonMounted(() => window.addEventListener('mousemove', update))\n\tonUnmounted(() => window.removeEventListener('mousemove', update))\n\n\treturn { x, y }\n}\n\n// Index.vue\n<script setup>\nimport { useMouse } from './mouse.js'\n\nconst { x, y } = useMouse()\n</script>\n\n<template>\n\t{{ x }}, {{ y }}\n</template>\n```\n\n## 三、指令\n\n### 3.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 3.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 3.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 3.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 3.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n### 3.6 自定义指令\n\n*为了重用 涉及普通元素的 底层dom访问 的逻辑*\n\n定义：\n\n1. 在 `<script setup> ` 中以v开头的驼峰式命名的变量，被用作一个自定义指令。\n2. 其他情况，需要使用 directives 选项注册\n3. app.directive 全局定义\n\n```javascript\n// 方式一\n<script setup>\nconst vFocus = {\n\tmounted: (el) => el.focus()\n}\n</script>\n\n<template>\n\t<input v-focus />\n</template>\n\n// 方式二\n<script>\nexport default {\n\tsetup() {}\n\tdirectives: {\n\t\tfocus: {\n\t\t\t//\n\t\t}\n\t}\n}\n</script>\n\n// 全局注册\nconst app = createApp({})\n\napp.directive('focus', {\n\t// \n})\n\n// 简化形式，在mounted和updated是执行此函数\napp.directive('color', (el, binding) => {\n\tel.style.color = binding.value\n})\n```\n\n指令钩子\n\n1. created 绑定元素的 attribute 前，时间监听器应用前\n2. beforeMount  元素被插入dom前调用\n3. mounted 元素的父组件、子节点都挂载完成后调用\n4. beforeUpdate 元素的父组件更新前调用\n5. updated 元素的父组件、子节点都更新后调用\n6. beforeUnmount 元素的父组件卸载前调用\n7. unmounted 元素的父组件卸载后调用\n\n钩子参数\n\n1. el 指令绑定到的元素\n2. binding 对象\n   1. value 传递给指令的值 `v-focus=\"2\"`\n   2. oldValue 之前的值\n   3. arg 传递给指令的参数 `v-focus:bar, ` 参数可以是动态的\n   4. modifiers 修饰符对象 `v-focus.foo.bar `对象是，`{ foo: true, bar: true }`\n   5. instance 使用该指令的组件实例\n   6. dir 指令的定义对象\n3. vnode 绑定元素的底层VNode\n4. preVnode 之前的渲染中指令所绑定的VNode\n\n*当在组件上使用自定义指令时，会始终应用于组件的根节点。但是不推荐在组件上使用自定义指令*\n\n## 四、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n## 五、组件\n\n### 5.1 动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n\n### 5.2 组件命名\n\n子组件命名和使用，使用大驼峰\n\n### 5.3 Slot\n\n1. 作用域，\n   1. 渲染作用域：默认情况下，模版中的表达式只能访问其定义时所处的作用域。即插槽内容无法访问子组件的数据\n   2. 作用域插槽：插槽内容想访问子组件的数据，可以在slot时向出口传递参数\n\n      ```javascript\n      // 子组件 Head\n      <div>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head v-slot=\"slotProps\">\n      \t{{ slotProps.text}}: {{ slotProps.count }}\n      </Head>\n\n      // 具名插槽传参，name是特殊参数，不会作为props传递\n      // 子组件 Head\n      <div>\n      \t<slot name=\"head\" :text=\"msg\" :count=\"1\"></slot>\n      \t<slot :text=\"msg\" :count=\"1\"></slot>\n      \t<slot name=\"footer\" :text=\"msg\" :count=\"1\"></slot>\n      </div>\n\n      // 父组件\n      <Head>\n      \t<template #head=\"headerProps\">\n      \t// 使用参数，有具名slot时，默认插槽需要使用显式标签，不能使用v-slot来获取参数\n      \t<template #default=\"defaultProps\">\n      \t<template #footer=\"footerProps\">\n      </Head>\n      ```\n2. 默认内容 `<slot> submit </slot>`\n3. 具名插槽\n   1. ``<template v-slot:head>`  或者 <template #head> ``名称可以是变量\n   2. 使用name来定义slot名称 ``<slot name=\"head\"> ``没有定义的默认是default\n   3. 所有位于顶级的非template节点都被隐式的视为默认插槽的内容\n4. 无渲染组件：只包含逻辑而不需要自己渲染内容的组件\n\n### 5.4 异步组件\n\n在需要时再从服务器加载相关组件\n\n使用 defineAsyncComponent 和 es模块动态导入 import，vite和webpack支持此语法，并且会将它们作为打包时的代码分割点\n\n```javascript\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n\timport('./head/Head.vue')\n})\n\n// 也可以使用全局注册\napp.component('Head', defineAsyncComponent(() => {\n\timport('./head/Head.vue')\n}))\n\n// 支持高级选项处理加载错误状态\nconst AsyncComp = defineAsyncComponent({\n\tloader: import('./head/Head.vue'),\n\tloadingComponent: Load, // 在异步组件加载时展示\n\tdelay: 200, // 加载前有200ms的延迟，为了可以完整展示加载组件\n\terrorComponent: Error, // 加载失败时展示的组件\n\ttimeout: 3000, // 超过3000ms还没加载出来，就展示失败组件\n})\n\n\n// 搭配Suspense组件使用\n```\n\n### 5.5 依赖注入\n\nprovide, inject\n\n```javascript\n// 父组件\nimport { provide, readonly } from 'vue;\n\nprovide('msg', 'hello'); // key值可以是string或symbol\n\n// value可以是任意类型，包含ref，可以和后代组件建立响应式联系\nconst num = ref(0)\nprovide('num', num);\n\n// 使用readonly来确保提供的数据不能被子组件更改\nprovide('num-only', readonly(num))\n\n\n// 在整个应用层面提供依赖\nimport { createApp } from 'vue';\n\nconst app = createApp({})\napp.provide('msg', 'hello')\n\n\n// 子组件\nimport { inject } from 'vue';\n\nconst msg = inject('msg')\nconst num = inject('num') // 不会自动解构\n\n// 如果在注入时不要求必须有提供者，那么需要提供一个默认值\nconst head = inject('head', 'haha')\n\n// 默认值需要函数调用或初始化类获取时，可以使用工厂函数来避免在用不到默认值的情况下不进行计算，\n// 需要传递第三个参数来表示默认值是工厂函数\nconst value = inject('key', () => getValue(), true)\n\n```\n\n*注意：将响应式的变更都放在提供方组件中，如果需要在子组件更改的话，应该在提供方组件中提供一个更改数据的函数*\n\n### 5.6 内置组件\n\n#### Transition\n\n*在一个元素或组件进入和离开DOM时应用动画，仅支持单个元素，或有一个根元素的组件*\n\n进入和离开时，会先检测css过渡或动画，再调用监听的 js 钩子，再执行\n\n1. 触发条件：`v-if`、`v-show`、`v-if` / `v-else` / `v-else-if`、`key`属性改变、由 `<component> `切换的动态组件。\n2. 动画各个阶段的class，可以为class写css动画:\n\n   ![1712815739846](assets/image/20240222/1712815739846.png)\n\n   * 可以使用 name 自定义前缀：`<transition name=\"yu\"> ，那么 v-enter-from -> yu-enter-from `，name支持变量\n   * 自定义class，使用第三方css动画库时会用到：`<transition enter-active-class=\"animate__active\">`\n   * 阶段开始时，class自动添加至元素上，完成后，class自动被移除。\n   * 过渡结束事件：transitionend 或 animationend，取决于使用了哪个css，如果都有使用，则需要使用type来确定事件。`<transition type=\"animation\" >`\n   * 可以使用选择器为深层次的子元素写 css 动画，可以使用 duration 属性来指定过渡的总时间\n   * 性能考虑：使用transform  opacity这种不会影响dom结构 不会进行css布局重新计算的，height margin这种需谨慎使用\n3. js 钩子\n\n   ```javascript\n   <Transition\n     :css=\"false\" \n     // 默认事件会在css动画和js执行的动画时 都触发。\n     // 如果仅是js执行动画，可以加上这个属性，表明不会自动添加和移除class，可以跳过css过渡的探测，性能好\n     // 此时 钩子回调函数的done就是必须的，在过渡效果完成后调用，否则回调函数执行完就认为过渡完成\n     @before-enter=\"onBeforeEnter\"\n     @enter=\"onEnter\" // 开始插入，开始进入动画\n     @after-enter=\"onAfterEnter\"\n     @enter-cancelled=\"onEnterCancelled\"\n     @before-leave=\"onBeforeLeave\"\n     @leave=\"onLeave\"\n     @after-leave=\"onAfterLeave\"\n     @leave-cancelled=\"onLeaveCancelled\"\n   >\n     <!-- ... -->\n   </Transition>\n\n   ```\n4. 可封装 Transition 组件，从而复用过渡效果\n5. 其他属性:\n\n   * appear 只在元素初次渲染时应用\n   * mode 过渡模式 out-in 表示 先执行离开动画再执行进入动画\n\n#### TransitionGroup\n\n*用于对v-for列表中的元素或组件的插入、移除和顺序改变添加动画效果*\n\n支持和Transition一样的class 属性 js钩子等\n\n特殊：\n\n1. 需要使用 tag 来指定容器元素\n2. mode 属性不可用\n3. 列表中的元素必须有唯一的 key\n4. class 会被添加至列表内的元素，而不是容器元素\n5. class 新增 v-move 表示对移动中的元素的过渡\n\n```javascript\n<TranstionGroup name=\"list\" tag=\"ul\">\n\t<li v-for=\"item in items\" :key=\"item.id\">\n\t\t{{ item.msg }}\n\t</li>\n</TransitionGroup>\n```\n\n#### KeepAlive\n\n*在多个组件间动态切换时 缓存被移除的组件实例*\n\n```javascript\n// 在切换组件时，会缓存组件状态，切换回来时 状态保留\n\n<KeepAlive>\n\t<component is=\"activeComp\" />\n</KeepAlive>\n\n// 默认会缓存内部所有的组件实例，但可以通过 include 和 exclude 来定制该行为\n// 值可以使逗号分隔的字符串、正则表达式、数组，会根据组件的 name 进行匹配\n\n<KeepAlive include=\"a,b\">\n\t<component is=\"activeComp\" />\n</KeepAlive>\n\n// 使用 max 来限制可被限制的最大组件实例数，超过时，最久没被访问的缓存实例被销毁\n```\n\n被切换时，从dom上移除，但是由于被缓存而作为组件树的一部分，状态变为不活跃而不是被卸载。\n\n当切换回来时，会插入到DOM中，将被激活\n\n生命周期钩子，不仅适用于KeepAlive缓存的根组件，也适用于缓存树中的后代组件：\n\n1. onActivated 首次挂载 和 从缓存中被重新插入时\n2. onDeactivated 从dom移除 进入缓存时，和 卸载时\n\n\n#### Teleport\n\n*将一个组件内部的一部分模版“传送”到该组件的 DOM 结构外层的位置去*\n\n1. to 来指定传送的目标。to 可以是 选择器字符串 或 dom元素对象\n2. disabled 禁用传送，当做行内元素\n3. 多个teleport to一个目标，按顺序依次追加\n\n```javascript\n<template>\n\t<button @click=\"open = true\"> open modal </button>\n\t<Teleport to=\"body\">\n\t\t<div v-if=\"open\" class=\"modal\">\n\t\t...\n\t\t</div>\n\t</Teleport>\n</template>\n```\n\n\n#### Suspense\n\n协调 子组件树中 所有异步资源的处理，可以等待下层的所有异步资源解析完成，可以在等待时渲染一个加载状态\n\n1. 可以协调的异步资源：\n   1. 带有异步 setup 的组件，即 setup() 中有 await\n   2. `<script setup>` 时顶层有 await\n   3. 异步组件，异步组件中自定义的加载、报错、延时等配置均被忽略。但可以指定 suspensible: false 表明不用Suspense 控制\n2. 插槽，defauult、fallback。均只允许一个直接子节点\n   1. 初始渲染时，渲染默认插槽内容，如果有任何异步依赖，则进入挂起状态，渲染fallback插槽内容。当所有异步依赖都完成后，则进入完成状态，渲染默认插槽的内容\n   2. 当默认插槽被替换时，suspense会回到挂起状态，但是不会展示fallback插槽，而是展示之前默认插槽的内容。可以使用timeout进行控制此行为，timeout表示渲染耗时多久后会展示fallback插槽\n3. 事件\n   1. pending 进入挂起状态\n   2. resolve 默认插槽完成获取新内容时\n   3. fallback fallback插槽显示时\n4. 错误处理：在使用suspense的组件中。使用errorCaptured 选项 或者 onErrorCapture钩子\n\n\n\n## 六、插件\n\n*是一种能为Vue添加全局功能的工具代码*\n\n```javascript\n// 使用\napp.use(myPlugin, {\n\t// 额外参数\n})\n\n// 定义\nconst myPlugin = {\n\tinstall(app, options) {\n\t\t// app为安装此插件的应用实例，options为额外参数\n\t\t// 插件代码\n\t\t// 可以使用app.provide提供一些内容\n\t}\n}\n```\n\n### 6.1 使用范围\n\n1. 通过 app.component 和 app.directive 注册一到多个全局组件或自定义指令\n2. 通过 app.provide 使一个资源可被注入进整个应用\n3. 向 app.config.globalProperties 中添加一些全局实例属性或方法\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""},{"content":"## 一、编译相关\n\nvue 提供了多种格式的 构建文件\n\n1. 前缀为 vue.runtime. 的文件是只包含运行时的版本，不包含编译器。当使用这个版本时，所有的模板都必须由构建步骤预先编译\n2. 名称中不含 .runtime 的文件是完全版，包含编译器。支持在浏览器中直接编译模板\n\n## 二、路由\n\n1. 服务端路由：用户发送一个http请求，服务端解析请求，返回响应结果。比如传统的服务端渲染，当用户交互更改url，会请求服务端获取新的html，浏览器加载整个页面\n2. 客户端路由：对于这种单页应用，客户端监听路由更改（即拦截跳转请求），动态获取新的数据，更新页面\n\n## 三、测试\n\n> 使用 Vitest（不基于浏览器，所以快，但是捕捉不到样式问题、原生dom问题、cookie等\n>\n> 使用 Cypress （基于浏览器的运行器，由于要执行打开浏览器，编译样式表等，所以慢\n\n### 1. 单元测试\n\n*适用于独立的JS\\TS模块：业务逻辑、组件、类、模块或函数。不涉及UI、网络请求或环境问题*\n\n针对于 Vue 的特殊的单元测试\n\n1. 组合式函数\n   1. 依赖于宿主组件，包含生命周期钩子、供给/注入。需要被包装在一个宿主组件中才可以测试\n\n      ```javascript\n      // 编写一个帮手函数，创建一个组件，并且在组件中执行组合式函数\n      // test-utils.js\n      import { createApp } from 'vue'\n\n      export function withSetup(composable) {\n        let result\n        const app = createApp({\n          setup() {\n            result = composable()\n            // 忽略模板警告\n            return () => {}\n          }\n        })\n        app.mount(document.createElement('div'))\n        // 返回结果与应用实例\n        // 用来测试供给和组件卸载\n        return [result, app]\n      }\n\n      import { withSetup } from './test-utils'\n      import { useFoo } from './foo'\n\n      test('useFoo', () => {\n        const [result, app] = withSetup(() => useFoo(123))\n        // 为注入的测试模拟一方供给\n        app.provide(...)\n        // 执行断言\n        expect(result.foo.value).toBe(1)\n        // 如果需要的话可以这样触发\n        app.unmount()\n      })\n      ```\n   2. 不依赖于宿主组件。直接调用并断言其返回的状态或方法\n\n      ```javascript\n      // counter.js\n      import { ref } from 'vue'\n\n      export function useCounter() {\n        const count = ref(0)\n        const increment = () => count.value++\n\n        return {\n          count,\n          increment\n        }\n      }\n\n      // counter.test.js\n      import { useCounter } from './counter.js'\n\n      test('useCounter', () => {\n        const { count, increment } = useCounter()\n        expect(count.value).toBe(0)\n\n        increment()\n        expect(count.value).toBe(1)\n      })\n      ```\n2. 组件\n   1. 白盒：单元测试，对组件进行更独立的测试\n   2. 黑盒：组件测试，测试组件在整个系统中的集成情况\n\n### 2. 组件测试\n\n*组件测试关注 prop 事件 slot 样式 生命周期钩子 用户交互 等，只关注组件做了什么，而不是如何实现的。*\n\n*所以不要测试组件的私有状态或私有方法。如果想测试一个私有方法，应该把他提到独立的实用函数中，然后写他的单元测试*\n\n```javascript\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\n\nconst wrapper = mount(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\nexpect(wrapper.find(valueSelector).text()).toContain('0')\n\nawait wrapper.find(buttonSelector).trigger('click')\n\nexpect(wrapper.find(valueSelector).text()).toContain('1')\n```\n\n### 3. 端到端测试\n\n*完全依靠在真实浏览器中浏览整个页面来测试你的应用， 测试 当用户实际使用你的应用时发生了什么*\n\n**推荐方案：Cypress**\n\n选择端到端测试方案 需要考虑的因素：\n\n1. 跨浏览器测试：了解应用在多个不同浏览器上运行的情况\n2. 更快的反馈：集成和部署（CI/CD） 快，支持本地开发时单独测试某个页面，支持热重载\n3. 调试体验\n4. 无头模式下的可见性：在CI/CD运行时，即在无界面的浏览器中运行。需要能查看应用的快照、视频，从而了解错误的原因\n\n\n## 四、服务端渲染（SSR)\n\n> 默认情况下，vue是在浏览器生成和操作dom。服务端渲染指的是，vue支持将组件在服务器生成html字符串，然后通过响应返回给浏览器，然后浏览器再将html字符串生成可交互的应用\n\n### 4.1 SSR的优势\n\n1. **更快的首屏加载**。无需等待浏览器将资源下载、执行后才展示；对于需要有数据请求的应用，有更快的数据库连接。\n2. 前后端统一语言\n3. 更好的seo，html中是完整的内容\n\n### 4.2 SSR的劣势\n\n1. 开发限制。第三方库在服务端渲染的应用中使用、一些浏览器端特定的代码执行\n2. 构建、部署限制。客户端渲染的应用是build后的文件夹部署在服务器上。SSR 由于用户交互时，会请求服务端拿到html进行渲染，所以还需要有node环境来运行服务端代码，以及可能的数据库连接等\n3. 更高的服务端负载\n\n是否使用SSR  取决于是否有很强烈的 **首屏加载速度** 要求\n\n### 4.3 SSG静态站点（预渲染）\n\n在构建过程，完成渲染，生成的html作为静态文件被服务器托管，每次请求时直接返回，不需要重新生成\n\n如果SSR渲染的页面对于所有人都是一样的，数据也都一样，比如/about  /contact 、博客网站等，那么可以使用SSG\n\n和SSR一样 有很好的首屏加载速度。但是比SSR花销更小，更容易部署\n\n### 4.4 实现服务端渲染\n\n1. 写通用内容：构建应用\n2. 写service：\n   1. 接口请求，构建应用，构建后的转成html string，拼完整的html，返回\n   2. 端口监听\n   3. 支持浏览器加载客户端文件\n3. 写client：构建和service一样的应用，挂载到dom上，用于用户交互时有反应\n\n更通用的方案：Nuxt 、Quasar\n\n### 4.4 书写SSR规范\n\n1. SSR期间避免响应性，都使用请求+service返回新的html\n2. 生命周期函数不会在SSR期间调用，只会在客户端运行\n3. 不要在SSR期间使用客户端特有api，比如window  document\n4. 状态污染。需要在每个请求中创建一个全新的实例，包括router和store，然后使用provide将store注入\n5. 激活不匹配，需要避免以下的问题\n   1. 不符合规范的html结构\n   2. 渲染所用的数据用到了随机数\n   3. 客户端和服务端时区，会不一致\n","data":{"title":"Vue 应用规模化","tag":"skill","date":"2024-04-26 17:50"},"isEmpty":false,"excerpt":""},{"content":"## 一、数组\n\n### 1. reduce\n\n> 对数组中的每个元素按序执行一个函数，每次运行函数会将上一次运行的结果作为参数传入，返回值为最后一次的运行结果\n\n参数：\n\n1. callbackFn(accumulator, currentValue)\n2. initialValue，不传时，初始值为第一个元素，即 accumulator 为 arr[0]，currentValue 为 arr[1]\n\n返回值：计算总值\n\n*获取不到 accumulator 时，会报错。即数组为空且无 initialValue 时*\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst initialValue = 0;\nconst sum = a.reduce((accumulator, currentValue) => accumulator + currentValue, initialValue)\n\nconsole.log(sum) // 10\n```\n\n\n\n### 2. reduceRight\n\n> 和reduce 不同之处在于：数组从右往左执行函数\n\n\n### 3. slice\n\n> 对原数组的浅拷贝，返回一个新数组，原数组不会被改变\n\n参数：[start, end)\n\n1. 如果是负数，则从数组末尾开始计算，-1 表示最后一个。\n2. start 非必填，默认从0开始\n3. end 非必填，默认为arr.length\n\n返回值：浅拷贝的新数组\n\n```javascript\nconst a = [1, 2, 3, 4]\nconst b = a.slice(1, 2) // 2\n```\n\n### 4. splice\n\n> **就地**移除或替换数组元素\n\n参数\n\n1. start，必填，开始计算的索引\n2. deleteCount，删除的数量\n3. item1 ... itemN，要加入数组的元素\n\n返回值：包含删除元素的数组\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst b = a.splice(1, 2, 'c')\n\nconsole.log(a) // [1, 'c', 4 ]\nconsole.log(b) // [2, 3]\n```\n\n### 5. toSpliced\n\n> 和splice方法不同的是：\n>\n> 1. 不会更改原数组，是返回一个新数组\n> 2. 不会返回稀疏数组，空槽会被替换成undefined\n\n```javascript\nconst a = [1, 2, 3, 4]\n\nconst b = a.splice(1, 2, 'c')\n\nconsole.log(a) // [1, 2, 3, 4]\nconsole.log(b) // [1, 'c', 4]\n```\n","data":{"title":"常用的 js 方法","tag":"skill","date":"2024-04-26 09:44"},"isEmpty":false,"excerpt":""},{"content":"## 一、背景\n\n业务需要在网络环境差时也可使用，所以希望实现离线存储和同步。\n\n## 二、目的\n\n无网时功能可以正常使用，有网时可以将操作的数据同步至远端。\n\n## 三、整体方案\n\n1. 搭建本地数据库，按照组织进行分库。按照业务进行表搭建\n2. 在线时，拉取数据：各个业务进行网络请求，将数据写入本地数据库\n3. 离线时，拦截请求：各个业务针对接口写拦截器，增删改查本地数据库的数据，增删改操作入log表\n4. 在线时，推送数据：遍历log表，执行对应业务的对应函数，进行网络请求，从而进行数据同步\n\n## 四、具体实现\n\n### 4.1 数据库搭建\n\n业务要求：当前业务场景，存在多个组织，且不同组织数据不同。希望在线时可以同步多个组织的数据，即切换组织时不要清库。\n\n所以决定根据组织 id 分库，当前操作的数据库，为当前组织id的库\n\n数据库搭建和数据操作使用 dexie，它是 indexDB 的包装库\n\n1. 针对表构建，写装饰器，从而方便进行表定义\n\n   1. @Entity：建表。将class放在allEntity set中，并为这个class 增加 Info: { name } 的元数据\n   2. @column 定义一个表字段 columnKey。为这个 class 增加 columnKey: { ..., 属性名 } 的元数据\n   3. @IndexColumn 定义一个可索引字段 indexKey。为这个class 增加 indexKey: { ..., 属性名 } 的元数据\n   4. @PrimaryColumn 定义一个主键 primaryKey，可用于update delete。为这个class 增加 { primaryKey: 属性名 } 的元数据\n2. 基于dexie 封装 indexDBStore，创建实例，封装 CURD 方法\n\n   1. select：\n      1. 获取到当前this，即当前表，即当前class的info元数据，获取到了表名\n      2. 获取 primaryKey 元数据，获取到了主键\n      3. 获取 indexKey 元数据，获取到了可索引属性名list\n      4. 调用dexie api 来 select 库中此表的查询数据\n   2. insert\n   3. update\n   4. delete\n   5. clear\n3. 封装表的相关方法，获取表、基于 IndexDBStore 封装从这个表中CURD的方法\n\n   1. getRespository：返回 包含下面 CURD 方法的对象\n      1. select：indexDBStore.select.bind(A)  A是定义的某个表class\n      2. insert\n      3. update\n      4. delete\n      5. clear\n4. 新增_localId字段：表中插入一个数据时，会新增_localId字段，来作为主键，唯一标识表中此条数据\n\n### 4.2 离线操作日志 搭建\n\n#### 4.2.1 Log表字段：\n\n1. id\n2. bizCode，业务标识\n3. type，操作标识\n4. bizLocalIds，执行的数据在业务表中的localId（主键），根据这个可以拿到完整的数据\n5. params，get接口 参数\n6. body，post接口 参数\n7. isSync，是否同步过\n\n#### 4.2.2 操作日志方案：\n\n1. 离线时，业务的所有增删改操作，都作为操作日志入log表\n2. 在线同步时，遍历log表，根据bizCode 执行对应的业务，根据type 执行对应的具体操作。\n\n#### 4.2.3 各个业务有如下数据，用于UI交互\n\n1. total\n2. count\n3. status\n\n#### 4.2.4 各个业务表，增加 realId 字段\n\n1. 默认值为id字段的值。\n2. 同步时，add一个数据后，接口会返回数据的真实id，然后将这个真实id存到业务表中对应数据的realId字段中。目的是后续如果有其他业务关联这条数据的话，可以关联到真实id\n\n### 4.3 拦截器\n\n1. 各个业务写各自接口的拦截器，参数1：url，参数2：拦截后的执行函数\n2. 将这些拦截器存到mapper中\n3. 使用 axios.create 创建一个 axios 实例\n4. 使用 interceptors 拦截请求，进行请求头等处理操作\n5. 使用 axios-mock-adapter 拦截到请求，进行响应处理。当在线时，返回原有的接口请求。离线时，执行mapper中url对应的执行函数\n\n### 4.4 在线同步\n\n![1714379419164](assets/image/离线存储&同步/1714379419164.png)\n\n### 4.5 业务开发\n\n在线场景，同步功能\n\n1. 各个业务 注册多个任务，各个任务包含执行函数和状态，store中存储各个任务的状态，在执行任务时先判断状态，如果被取消 或者 失败，则抛出异常，中断任务，后续任务也不进行。\n2. 开始同步\n   1. 下载基础数据 common data\n   2. 上传 业务数据\n   3. 下载 业务数据\n3. 取消同步：更改任务的状态\n\n离线场景，拦截器\n\n1. 构建表结构\n2. 使用正则表达式url拦截接口请求，进行数据的增删改查操作\n3. 应用入口使用此业务拦截器插件\n\n### 4.4 调试工具\n\n1. mock数据 写入数据库\n2. 查看数据库\n3. 清空数据库\n\n### 4.5 目录结构\n\n```javascript\n---entity // 表定义\n   ---a // 表a\n   ---b\n   ...\n---offline // 离线\n   ---helper // 调试工具\n   ---store // 装饰器、表增删改查方法\n   ...\n---sync // 同步\n   ---syncBaseData // 同步基础数据\n   ---syncAData // 同步业务A数据\n   ---useSyncBaseData // 注册任务、执行任务、取消同步。。返回状态\n   ---useSyncAData\n   ---taskManage // 任务管理封装\n   ...\n---a // 业务a\n   ---offline // 业务a 相关接口的拦截器\n   ...\n```\n","data":{"title":"离线存储 & 同步","tag":"skill","date":"2024-04-01 16:00"},"isEmpty":false,"excerpt":""}]}
