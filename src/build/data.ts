export const allBlogs = [{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""},{"content":"**仅包含 组合式 写法的学习，相较于 Vue2 不同之处**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\nconst emit = defineEmits(['enlarge-text'])\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n## 二、指令\n\n### 2.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 2.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 2.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 2.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 2.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n\n\n## 三、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n\n动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""}]

export const tagBlogs = {"life":[{"content":"\n## 学习\n1. 学完 vue3，并进行项目实践\n2. 学完 数据结构与算法 概念\n3. 多邻国 完成第三阶段和第四阶段\n3. 每周至少一道算法题\n4. 每月至少产出一篇博客\n\n<br>\n\n## 生活\n1. 苏州旅行\n2. 日本旅行\n3. 减脂至58kg\n","data":{"title":"2024年规划","tag":"life","date":"2024-02-21 13:32"},"isEmpty":false,"excerpt":""}],"skill":[{"content":"**仅包含 组合式 写法的学习，相较于 Vue2 不同之处**\n\n## 一、组合式API\n\n```js\n// 写法一\n<script>\n  setup() {\n    const count = ref(0);\n    function increment() {};\n    // 在模版中使用的数据和方法需要返回\n    return {\n  \tcount,\n\tincrement\n    }\n  }\n</script>\n\n// 写法二，简化写法一，script中的顶层的导入、声明的变量、函数可以在模版中直接使用\n<script setup>\n  const count = ref(0);\n  function increment() {};\n</script>\n```\n\n### 1.1 响应式数据\n\n1. ref\n\n   ```js\n   // 声明\n   const count = ref(0);\n\n   // 获取\\设置\n   count.value\n\n   // 模版中获取\n   count\n   ```\n2. reactive\n\n   ```js\n   // 声明\n   const state = reactive({ count: 0 }})\n\n   // 获取、模版获取、设置\n   state.count\n   ```\n\n*注意：*\n\n1. *简单类型使用ref，复杂类型使用reactive*\n2. *reactive，结构后的属性会丢失响应性*\n\n### 1.2 计算属性\n\ncomputed\n\n```js\n// 声明\nconst msg = computed(() => {\n\treturn count.value > 1 ? 'yes' : 'no';\n})\n\n// 获取，返回的是一个ref\nmsg.value\n\n// 模版获取\nmsg\n```\n\n### 1.3 侦听器\n\n1. watch\n\n   ```js\n   // 监听一个ref\n   watch(count, (new, old) => {\n   \t// do something\n   })\n\n   // 监听响应式对象的属性值，不能直接监听，要使用getter函数\n   watch(\n   \t() => obj.count,\n   \t(count) => {\n   \t\tconsole.log(count)\n   \t}\n   )\n\n   // 多个来源组成的数组\n   watch([x, () => y.value], ([newX, newY]) => {})\n\n   // 监听一个reactive响应式对象，会创建一个深层监听器，所有嵌套变更时都会触发\n   watch(obj, (new, old) => {\n   \t// new 和 old是相等的，因为他们是同一个对象\n   })\n\n   // 监听返回一个响应式对象的getter函数，不会创建深层监听器，只有在对象被替换时才会触发\n   watch(() => state.obj, (new, old) => {})\n\n   // 上个例子，可以加个 deep 转成深层监听器\n   watch(\n   \t() => state.obj,\n   \t(new, old) => {\n   \t\t// new 和 old是相等的，因为他们是同一个对象，除非state.obj被整个替换\n   \t},\n   \t{ deep: true }\n   )\n\n   // 立即执行，监听到改变时再执行\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ immediate: true }\n   )\n\n   // 只执行一次\n   watch(\n   \tcount,\n   \t(new, old) => {\n   \t\t// do something\n   \t},\n   \t{ once: true }\n   )\n   ```\n2. watchEffect，自动跟踪回调的响应式依赖的变更，并且立即执行\n\n   ```js\n   watchEffect(() => {\n   \tconsole.log(count.value)\n   })\n   ```\n\n*注意：回调的触发时机，会在父组件更新之后，当前组件dom更新之前*\n\n```js\n// 希望在dom更新之后执行\n// watch\nwatch(source, callback, {\n  flush: 'post'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'post'\n})\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n\n// 在 vue 任何更新前触发\n// watch\nwatch(source, callback, {\n  flush: 'sync'\n})\n\n// watchEffect\nwatchEffect(callback, {\n  flush: 'sync'\n})\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n\n```\n\n### 1.4 Props & Emit\n\n```js\n// 方式一\n<script setup>\n// 声明props, 声明emit\nconst props = defineProps(['title'])\nconst emit = defineEmits(['enlarge-text'])\n// 调用\nconsole.log(props.title)\nemit('enlarge-text')\n</script>\n\n// 方式二\nexport default {\n  // 声明\n  props: ['title'],\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    // 调用\n    console.log(props.title)\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n## 二、指令\n\n### 2.1 v-if 和 v-for\n\n1. 不要同时使用\n2. 都可在 template 上使用\n\n### 2.2 v-for\n\n1. 遍历对象，(value, key, index)\n2. 遍历整数n，v-for=\"n in 10\"，会从1到10重复\n3. 默认 就地更新 策略，建议给个唯一值key\n\n### 2.3 v-on\n\n```js\n// 内联事件\n<span @click=\"count++\">11</span>\n<span @click=\"foo()\">11</span>\n// 传参\n<span @click=\"foo('hey')\">11</span>\n<span @click=\"foo('hey', $event)\">11</span>\n<span @click=\"(event) => foo('hey', event)\">11</span>\n\n// 方法事件\n<span @click=\"foo\">11</span>\n```\n\n### 2.4 ref\n\n1. 可以绑定为一个函数，在每次组件更新时被调用 `<input :ref=\"(el) => {}\">`\n2. 选项式，父组件可以通过 ref 调用子组件的数据和方法\n3. `<script setup>` 组件默认是私有的，父组件访问不到，除非子组件通过defineExpose 宏显示暴露\n\n   ```js\n   // 像 defineExpose 这样的编译器宏不需要导入\n   defineExpose({\n     a,\n     b\n   })\n   ```\n\n### 2.5 v-model 数据双向绑定\n\n1. defineModel\n\n   1. 子组件使用defineModel宏返回一个ref值，他的.value和父组件的v-model值一起更新。宏做了两个事：\n      1. modelValue prop\n      2. update: modelValue emit\n   2. 可通过传参，来声明prop\n      1. required 必填\n      2. default 默认值\n2. v-model的参数，定义数据名称 v-model:title\n3. 多个v-model，v-model:first   v-model:last\n4. 修饰符\n\n   1. .lazy，在change事件后更新数据，而不是input事件\n   2. .number，数据使用parseFloat()自动转换为数字，转换失败，则返回原始值\n   3. .trim，自动去除数据两端的空格\n   4. 自定义修饰符\n\n   ```javascript\n   // 子组件 child\n   <script setup>\n   const model = defineModel()\n\n   function update() {\n   \tmodel.value++\n   }\n   </script>\n\n   <template>\n   \t<div> {{ model}} </div> <span @click=\"update\">add</span>\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model=\"title\" />\n   </template>\n   ```\n\n   ```javascript\n   // 子组件 child 多个参数\n   <script setup>\n   // 必填参数, 自定义修饰符\n   const [firstName, firstNameModifiers]= defineModel('firstName', { required: true })\n   // 默认值参数\n   const lastName= defineModel('lastName'{ default: 'yu' })\n\n   if(firstNameModifiers.capitalize) {\n   \tfirstName.value = firstName.value.charAt(0).toUpperCase() + firstNamevalue.slice(1)\n   }\n\n   </script>\n\n   <template>\n   \t<input type=\"input\" v-model=\"firstName\" />\n   \t<input type=\"input\" v-model=\"lastName\" />\n   </template>\n\n   // 父组件\n   <template>\n   \t<child v-model:firstName.capitalize=\"name1\" />\n   \t<child v-model:lastName=\"name2\" />\n   </template>\n   ```\n\n\n\n## 三、生命周期\n\n```js\nonMounted(() => {\n\tconsole.log('mounted')\n})\n```\n\n|                                  | vue2          | vue3              |                 |\n| -------------------------------- | ------------- | ----------------- | --------------- |\n| 创建前                           | beforeCreate  | 用setup           | data: undefined |\n| 创建时，属性计算完成，dom未生成  | created       | 用setup           | data: { msg}    |\n| 挂载前，模版 数据挂载前          | beforeMount   | onBeforeMount     | {{ msg }}       |\n| 挂载后                           | mounted       | onMounted         | hello           |\n| 更新前                           | beforeUpdate  | onBeforeUpdate    |                 |\n| 更新时                           | updated       | onUpdated         |                 |\n| 卸载前                           | beforeDestroy | onBeforeUnmount   |                 |\n| 卸载后                           | destroyed     | onUnmounted       |                 |\n| 错误捕获                         | errorCaptured | onErrorCaptured   |                 |\n| render收集依赖调用，有几个调几次 | -             | onRenderTracked   |                 |\n| 某个依赖改变，触发渲染           | -             | onRenderTriggered |                 |\n\n\n动态组件\n\n`<component :is=\"tabs[currentTab]\"></component> ` 在多个组件切换时，被切换的组件会被卸载，可以通过 `<KeepAlive> `组件强制被切换掉的组件仍然保持“存活”的状态\n","data":{"title":"Vue3 学习","tag":"skill","date":"2024-02-22 10:54"},"isEmpty":false,"excerpt":""}]}
